-- Faça a classificação dos produtos mais venvidos usando usando RANK(), DENSE_RANK() e ROW_NUMBER()
-- Essa questão tem 2 implementações, veja uma que utiliza subquery e uma que não utiliza.
-- Tabelas utilizadas: FROM order_details o JOIN products p ON p.product_id = o.product_id;

SELECT
	p.product_id,
	p.product_name,
	sum(od.quantity) as total,
	RANK() OVER (ORDER BY sum(od.quantity) DESC) AS ranking,
	DENSE_RANK() OVER (ORDER BY sum(od.quantity) DESC) AS dense_ranking,
    ROW_NUMBER() OVER (ORDER BY sum(od.quantity) DESC) AS row_num
FROM order_details od JOIN products p ON p.product_id = od.product_id
GROUP BY p.product_id, p.product_name
ORDER BY total DESC;

-- Listar funcionários dividindo-os em 3 grupos usando NTILE
-- FROM employees;

SELECT NTILE(3) OVER(ORDER BY(first_name, last_name, employee_id)) AS group,
       employee_id,
	   first_name,
	   last_name
FROM employees

-- Ordenando os custos de envio pagos pelos clientes de acordo com suas datas de pedido,
-- mostrando o custo anterior e o custo posterior usando LAG e LEAD:
-- FROM orders JOIN shippers ON shippers.shipper_id = orders.ship_via;

SELECT
	order_id,
	ship_name,
	order_date,
	LAG(freight, 1) OVER (PARTITION BY customer_id ORDER BY order_date, order_id) as previous_freight,
	LEAD(freight, 1) OVER (PARTITION BY customer_id ORDER BY order_date, order_id) as next_freight
FROM orders

-- Desafio extra: questão de entrevista Google
-- https://medium.com/@aggarwalakshima/interview-question-asked-by-google-and-difference-among-row-number-rank-and-dense-rank-4ca08f888486#:~:text=ROW_NUMBER()%20always%20provides%20unique,a%20continuous%20sequence%20of%20ranks.
-- https://platform.stratascratch.com/coding/10351-activity-rank?code_type=3
-- https://www.youtube.com/watch?v=db-qdlp8u3o
